import argparse
import glob
import json
import os
import time
from datetime import datetime, UTC, timedelta
from operator import attrgetter

import util
from cache import Cache
from scanners.fdroid_scanner import FDroidScanner
from scanners.github_meta_scanner import GithubMetaScanner
from scanners.github_code_scanner import GithubCodeScanner


def scan_apps(github_auth):
    apps = []
    apps.extend(FDroidScanner("https://f-droid.org/repo/index.xml").find_matching_apps())
    apps.extend(FDroidScanner("https://apt.izzysoft.de/fdroid/repo/index.xml").find_matching_apps())
    if github_auth is not None and len(github_auth) > 0:
        apps.extend(GithubCodeScanner(github_auth, exclude=apps, process_count=2).find_matching_apps())
        apps.extend(GithubMetaScanner(github_auth, exclude=apps, process_count=2).find_matching_apps())
    return sorted(set(apps), key=attrgetter('name'))


def entry_to_string(app, ranked):
    score_str = f"[{"{:.2f}".format(app.score)}] " if ranked else ""    

    line = ""
    if len(app.urls) > 0:
        line += f" * {score_str}[{app.name}]({app.urls[0]})"
    else:
        line += f" * {score_str}{app.name}"

    if app.desc is not None:
        line += f" - {app.desc}"
    line += "\n"
    return line


def write_report(report_path, apps, ranked):
    with (open(report_path, 'w') as f):
        report = ("## Scan results\n"
                  "> [!IMPORTANT]\n"
                  "> This file is automatically generated. Do not edit.\n"
                  "\n"
                  "This document tracks all GitHub repos and F-Droid apps that make use of Shizuku in some way but are not yet "
                  "listed in the awesome-shizuku list. Please note that many of these apps are often incomplete or sometimes even false positives.\n"
                  "Typically, these apps will be added to the list as soon as possible; however, unfinished apps are usually left in this document until they reach a usable state.\n"
                  "\n")

        if not ranked:
            report += "Sort by: [name] | [score](SUMMARY_RANKED.md)\n\n"
            report += "Entries are sorted by name and grouped into a separate category if the attached link has no downloadable releases.\n\n"
        else:
            apps = sorted(apps, key=lambda x: x.score, reverse=True)
            report += "Sort by: [name](SUMMARY.md) | [score]\n\n"
            report += "Entries are sorted by a score that is calculated based on quality of the linked repository (readme, has downloadable release, stars, etc.).\n\n"

        if ranked:
            for app in apps:
                report += entry_to_string(app, ranked)
        else:   
            with_downloads = [a for a in apps if a.has_downloads]
            # 4 months = 17 weeks
            now = datetime.now(UTC)
            four_months = timedelta(weeks=17)
            new_and_no_downloads = [a for a in apps if not a.has_downloads and (a.last_updated is None or (now - a.last_updated) <= four_months)]
            old_and_no_downloads = [a for a in apps if not a.has_downloads and (a.last_updated is not None and (now - a.last_updated) > four_months)]
            for app in with_downloads:
                report += entry_to_string(app, ranked)

            if len(new_and_no_downloads) > 0 or len(old_and_no_downloads) > 0:
                report += f"\n### Apps with no releases\n\n"
                
            if len(new_and_no_downloads) > 0:
                report += f"\n#### Updated in the last 4 months\n\n"
                for app in new_and_no_downloads:
                    report += entry_to_string(app, ranked)

            if len(old_and_no_downloads) > 0:
                report += f"\n#### Updated more than 4 months ago\n\n"
                for app in old_and_no_downloads:
                    report += entry_to_string(app, ranked)

        f.write(report)
            


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("targetPath")
    args = parser.parse_args()

    github_auth = os.getenv("GITHUB_AUTH")
    if github_auth is None or len(github_auth) < 1:
        print("error: GITHUB_AUTH env variable not set; skipping GitHub scanners")

    summary_file = os.getenv("SUMMARY_FILE")
    if summary_file is None or len(summary_file) < 1:
        summary_file = "SUMMARY.md"

    path = args.targetPath
    util.readme_paths = glob.glob(path + '/*.md') + glob.glob(path + '/pages/UNLISTED.md')
    report_path = os.getcwd() + "/" + summary_file
    report_ranked_path = os.getcwd() + "/" + summary_file.replace(".md", "") + "_RANKED.md"

    cache_dir = os.getcwd() + "/cache"
    if not os.path.exists(cache_dir):
        os.mkdir(cache_dir)

    cache = Cache(cache_dir)
    cached_apps = cache.load_all()

    def remove_ignored_entries(a):
        return not (a.name in util.ignore_list or any(url in util.ignore_list for url in a.urls))

    apps = util.filter_known_apps(scan_apps(github_auth))
    apps = list(filter(remove_ignored_entries, apps))
    cache.save_current_run(apps)
    print()

    apps.extend(cached_apps)
    apps = sorted(set(apps), key=attrgetter('name'))
    apps = util.filter_known_apps(apps)
    apps = list(filter(remove_ignored_entries, apps))

    write_report(report_path, apps, ranked=False)
    write_report(report_ranked_path, apps, ranked=True)

    # Print to console
    for app in apps:
        print(app.scanner + ": " + app.name + " " + str(app.urls))
    time.sleep(0.5)


if __name__ == '__main__':
    main()
