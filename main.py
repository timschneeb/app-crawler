import argparse
import glob
import os
import time
from datetime import datetime, UTC
from operator import attrgetter

import util
from cache import Cache
from scanners.fdroid_scanner import FDroidScanner
from scanners.github_code_scanner import GithubCodeScanner
from scanners.github_meta_scanner import GithubMetaScanner


def scan_apps(github_auth):
    apps = []
    apps.extend(FDroidScanner("https://f-droid.org/repo/index.xml").find_matching_apps())
    apps.extend(FDroidScanner("https://apt.izzysoft.de/fdroid/repo/index.xml").find_matching_apps())
    if github_auth is not None and len(github_auth) > 0:
        apps.extend(GithubCodeScanner(github_auth, exclude=apps, process_count=4).find_matching_apps())
        apps.extend(GithubMetaScanner(github_auth, exclude=apps, process_count=4).find_matching_apps())
    return sorted(set(apps), key=attrgetter('name'))


def entry_to_string(app):
    line = f" * [{app.name}]({app.urls[0]})"
    if app.desc is not None:
        line += f" - {app.desc}"
    line += "\n"
    return line

def section_to_string(title: str, apps: list) -> str:
    report = "\n"
    now = datetime.now(UTC)
    three_months = 3 * 30 # days
    new = [a for a in apps if (a.last_updated is not None and (now - a.last_updated).days <= three_months)]
    old = [a for a in apps if a not in new]

    if len(new) > 0 or len(old) > 0:
        report += f"### {title}\n\n"

    if len(new) > 0:
        report += f"#### Updated in the last 3 months\n\n"
        for app in new:
            report += entry_to_string(app)

    if len(old) > 0:
        report += f"\n#### Updated more than 3 months ago\n\n"
        for app in old:
            report += entry_to_string(app)

    return report



def write_report(report_path, apps):
    with (open(report_path, 'w') as f):
        report = ("## Scan results\n"
                  "> [!IMPORTANT]\n"
                  "> This file is automatically generated. Do not edit.\n"
                  "\n"
                  "This document tracks all GitHub repos and F-Droid apps that make use of Shizuku in some way but are not yet "
                  "listed in the awesome-shizuku list. Please note that many of these apps are often incomplete or sometimes even false positives.\n"
                  "Typically, these apps will be added to the list as soon as possible; however, unfinished apps are usually left in this document until they reach a usable state.\n"
                  "\n")

        report += "Entries are sorted by name and grouped into a separate category if the attached link has no downloadable releases.\n\n"
        report += section_to_string("Apps with releases", [a for a in apps if a.has_downloads])
        report += section_to_string("Apps with no releases", [a for a in apps if not a.has_downloads])
        f.write(report)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("targetPath")
    args = parser.parse_args()

    github_auth = os.getenv("GITHUB_AUTH")
    if github_auth is None or len(github_auth) < 1:
        print("error: GITHUB_AUTH env variable not set; skipping GitHub scanners")

    summary_file = os.getenv("SUMMARY_FILE")
    if summary_file is None or len(summary_file) < 1:
        summary_file = "SUMMARY.md"

    path = args.targetPath
    util.readme_paths = glob.glob(path + '/*.md') + glob.glob(path + '/pages/UNLISTED.md')
    report_path = os.getcwd() + "/" + summary_file
    
    cache_dir = os.getcwd() + "/cache"
    if not os.path.exists(cache_dir):
        os.mkdir(cache_dir)

    cache = Cache(cache_dir)
    cached_apps = cache.load_all()

    def remove_ignored_entries(a):
        return not (a.name in util.ignore_list or any(url in util.ignore_list for url in a.urls))

    apps = util.filter_known_apps(scan_apps(github_auth))
    apps = list(filter(remove_ignored_entries, apps))
    cache.save_current_run(apps)
    print()

    apps.extend(cached_apps)
    apps = sorted(set(apps), key=attrgetter('name'))
    apps = util.filter_known_apps(apps)
    apps = list(filter(remove_ignored_entries, apps))

    write_report(report_path, apps)

    # Print to console
    for app in apps:
        print(app.scanner + ": " + app.name + " " + str(app.urls))
    time.sleep(0.5)


if __name__ == '__main__':
    main()
